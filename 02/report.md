<center><h1>数据库概论第二次实习作业</center></h1>

> 原梓轩 2200010825
> 陈润璘 2200010848
> 任子博 2200010626

本次实习的目标是练习设计约束。

## 基础约束设计

本部分只设计基础的约束，这些约束的定义在建表的时候就可以实现。

- 缺省定义：`default` 关键字
- 外码定义的三种形式：`on delete cascade/set null/set default`
- 枚举型约束：`enum` 关键字 
- 检查约束：`check` 关键字

另外，还有一些约束是需要在建表之后再添加的，这些约束的定义在建表的时候无法实现。例如第二题 “声明Emp中的dno为参照Dept的外码， Dept的manager为参照Emp的外码” 中的约束。这是因为两者互相引用，先定义一个表再定义另一个表的约束是不可能的。这时候需要在建表之后再添加约束。

## 中级约束设计

本部分设计的约束需要在建表之后再添加。

- 延迟约束：`deferred` 关键字，但是在MySQL中不支持。替代的方案是临时设置约束是否生效来完成。即

    ```sql
    set foreign_key_checks=0;
    # add some data
    set foreign_key_checks=1;
    ```

- 行级约束：在 `alter table` 语句后加上约束即可。例如

    ```sql
    alter table some_table add constraint ...
    ```

- 函数设计：本题的题目要求是生成一个包含员工信息的序列号，构造方法是将各个信息部分的序号拼接。为了保证各个员工序号长度相同，在取序号时需要将长度不足的部分补零。

    ```sql
    create function some_func(params) returns ...
    reads sql data
    begin
    ...
    end;
    ```

## 高级约束设计

本部分的约束设计包含了触发器设计和关系范式的相关内容。

- 触发器：触发器的作用是在插入或更新前后执行一些操作。可以使用 `create trigger` 语句中定义触发器。例如

    ```sql
    create trigger some_trigger
    before insert on some_table
    for each row
    begin
        ...
    end;
    ```

    - 我们这里实现时同时写了 insert 和 update 两个触发器。例如第一题本例中在工资设定时级确定用户的职位等级，员工的职位变动可能会在员工新入职时确定，也可能会在员工更新工资时发生。
    - 第二题要求管理者的工资必须高于他所管理的任何一个员工，我们也采用了触发器来实现。在插入或更新数据前进行检查，如果不满足条件则抛出异常 `Error 45000`。我们这里提供了一个测试样例，会无法正常插入数据而抛出异常。
    - 第三题要求保证任何一个员工工资的变化额度，都应该体现在他所在部门的预算上面，这实际上是维护了物化视图。当员工工资变动时，触发器会更新部门的预算。为了更高的效率，我们不会对预算进行累加，而是直接根据当前员工的工资增量来更新部门的预算。当用户被删除时，相应的扣除部门的预算。

- 关系范式设计：关系范式设计是在建表时就要考虑的问题。我们在设计表的时候，尽量将数据分解到不同的表中，避免数据冗余。

    - 现在 STC(sno, tno, cno) 上成立函数依赖 tno→cno 和 (sno, cno)→tno。这本身是满足第三范式的。如果我们直接使用此方案构造触发器：每次插入一行时，检查是否有两行有相同的 tno 但有不同的 cno，如果有则抛出异常，另一个依赖同理。这样的设计是不合理的，因为这样的设计会导致每次插入一行都要检查所有的行，时间复杂度是 $O(n^2)$ 的。
    - 我们这里采用了另一种设计，把 STC 拆成 SC 和 TC 两个表，这样就不会出现数据冗余的情况。这样的设计是满足 BCNF 的。在代码中我们提供了相应的 insert procedure 来从 tempSTC 读取数据，并将其全部写入 STC。

综上，我们实现了所有的约束设计。在实现过程中，我们使用了 MySQL 的存储过程、触发器等功能，实现了所有的约束。我们在实现过程中，尽量避免了数据冗余，保证了数据的一致性和完整性。