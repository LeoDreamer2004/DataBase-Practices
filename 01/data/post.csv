title,author_id,problem_id,content,create_time
"直接计算就行",2,2,"完全就是枚举，for循环跑就可以，数据很小不超时",2019-07-01 00:00:00
"求大佬讲解",4,2,"我尝试用调和级数的逼近公式，但是有误差怎么办",2019-07-06 10:00:00
"map映射",3,3,"这一题将A-B=C转换成A-C=B，首先将A数组每个元素出现的次数统计起来，用map映射，最后将A数组每次减一个C，再将A数组扫一遍，将所有映射的次数和加起来就是答案",2019-08-01 00:00:00
"最佳做法——双指针",4,3,"双指针，一个指向A数组，一个指向B数组，如果A-B<C，那么A指针右移，如果A-B>C，那么B指针右移，如果A-B=C，那么A指针右移，B指针右移，直到A或B指针到达数组末尾",2019-08-02 00:00:00
"二分确实更好，但map也行",5,3,"楼下的都是用的二分查找，我用二分查找做了一次。 但我的A-B数对的代码也能AC，没有TLE，挺黑科技的。map求解。将每一个数字映射到map中，答案每次加上num[i]+c位置的数的个数，num[i]+c即为式子的另一个加数",2019-08-02 08:00:00
"不是简单的题目",2,4,"这个题要输出不同种的方案数，比一般的下降子序列要难。题目要求是“它们构成的价格队列不一样”，那么我准备拿一个数组存下这个最长下降子序列，但是这不现实，检查是否匹配是在最坏的情况下可能达到O(N^3)于是有了现在的解法，让我来简单证明说明一下：在dp过程中，f数组存的是最长下降子序列的长度，f数组的下标i是以i结尾的意思，所以最长下降子序列（除了最后一位外）的数据已经丢失，因此不能在方案数相加时再判断是否能加。从头来看，如果一个数列的第一个数与另一个数列的第一个数相同，那么现在可以判断它们相等，即可以把其中一个删掉。当不同的数接在它的后面时，又可以将它们判断为两个数列，这是不互相影响的。因为两个数列都可以由这个相等的数列转移而来。如果一个数列的第一个数与另一个数列的第一个数不同，那么它们不等，且无论后面添加什么，都不相等，即不删去，则按照普通的判断继续做。由上面的两点，我们已经把重复的删掉，这样可以防止重复计数。",2019-08-03 10:00:00
"第三个测试点WA求大佬debug",3,4,"用了最好的O(nlogn)算法，但是有一个过不去，大佬们帮忙看看",2019-08-03 07:00:00
"这题完全是数论题",5,5,"把那些含有因子2和5的扣除掉，再对10取余就行了",2019-08-03 20:00:00